/* simpleAdder.sable - A very simple program that recognizes two integers being added. */
Package prefixa ;
    
Helpers
    /* Our helpers */	
    digito = ['0' .. '9'] ;
    hex_digit = digito | ['a'..'f'] | ['A'..'F'];
    digito_bin = '0' | '1' ;
    espaco = ' ';
    rc = 13;
    nl = 10;
    all = [0 .. 0xffff];
    letter = [['a' .. 'z'] + ['A' .. 'Z']];
   	tab = 9;
    dot = '.';
    expo = 'E';
    name_part = letter (letter | digito | '_')*;
    name = name_part ('_' name_part)*;
    id = name;
    not_new_line = [all - nl];
    not_bracete_l = '{';
    not_new_aspa = [all - '"'];
    not_new_simples_aspa = [all - '''];
    number = digito+;
    nondigit = ['_' + [['a' .. 'z'] + ['A' .. 'Z']]];
    number_bin = ('0B' | '0b') digito_bin+ ;
    hex_number = '0x' hex_digit+;
 
 States
  normal,
  comment;
 
Tokens
   vazio = (espaco | rc | nl | tab)+;
   atribuicao = '<<';
   char_id = 'char';
   int_id = 'integer';
   bool_id = 'bool';
   real_id = 'real';
   barra_id = '|';
   if_id = 'if';
   else_id = 'else';
   start_block_id = 'start';
   end_block_id =  'end';
   not_id = 'not';
   and_id = 'and';
   or_id = 'or';
   comma = ',';
   none_id = 'none';
   
   soma = '+';
   menos = '-';
   mult = '*';
   div = '/';
   mod = '%';
   double_dot = ':';
   bool_type = 'true' | 'false';
   while = 'while';
   do = 'do';
   foreach = 'for each';
   l_par = '(';
   r_par = ')';
   l_bracket = '[';
   r_bracket = ']';
   l_brace = '{';
   r_brace = '}';
   igual_que = '=';
   menor_que = '<';
   menor_igual_que = '<=';
   maior_que = '>';
   maior_igual_que = '>=';
   semicolon = ';';
   true_id = 'true' ;
   false_id = 'false' ;
   vector_id = 'vetor';
   return = 'send back';
   scan =  'scan';
   print = 'print';
   string = '"'(not_new_aspa)* '"';
   char_var = ''' (not_new_simples_aspa)* ''' ; 
   comments = '#'(not_new_line)* nl; 
   long_comment = '{' (not_bracete_l*) '}';
   int_type = number | hex_number;
   real_type = '-'? (number dot number | number (dot number)? expo '-'? number);
   identifier = nondigit (digito | nondigit)*;
   number = '-'? number ;
   numero_bin = '-'? number_bin ;
   hex_number = hex_number;

Ignored Tokens
     vazio, comments, long_comment;
     

Productions

programa {-> programa } = decl_var* decl_func* {-> New programa ([decl_var], [decl_func]) };


decl_func {-> decl_func } = 
	 {tipo} 	   tipo identificador l_par r_par bloco_funcao					{-> New decl_func.tipo (tipo, identifier, Null, bloco_funcao) }   
	|{none} 	   none_id identifier l_par r_par bloco_funcao 					{-> New decl_func.none (none, identifier, Null, bloco_funcao) }   
	|{tipo_params} tipo identifier l_par decl_parametros r_par bloco_funcao 	{-> New decl_func.tipo (tipo, identifier, decl_parametros, bloco_funcao) }   
	|{none_params} none_id identifier l_par decl_parametros r_par bloco_funcao 	{-> New decl_func.none (none, identifier, decl_parametros, bloco_funcao) }  
    ;


decl_parametros {-> decl_parametros } = decl_parametro decl_param_adicional* {-> New decl_parametros (tipo, identifier, [decl_param_adicional]) };
decl_param_adicional { -> decl_param_adicional } = barra_id decl_parametro {-> New decl_param_adicional (decl_parametro) } ;
decl_parametro {-> decl_parametro } = tipo identifier {-> New decl_parametro (tipo, identifier) } ;
 
parametros {-> parametros } = stmt param_adicional* {-> New parametros (stmt, [param_adicional]) };
param_adicional {-> param_adicional } = barra_id stmt {-> New param_adicional (stmt) };


decl_var {-> decl_var } = tipo identifier id_adicional* semicolon {-> New decl_var (tipo, identificador, [id_adicional]) } ;


id_adicional {-> id_adicional } = comma identifier {-> New id_adicional (identifier) };


tipo {-> tipo } = {tipo_base} tipo_base {-> New tipo (tipo_base, Null) }
      | {vector} vector_id tipo_base l_bracket stmt r_bracket {-> New tipo (tipo_base, stmt) };

tipo_base = {int}  int_id 
 	       | {char} char_id
 	       | {bool} bool_id ;

comando_atrib = var atribuicao stmt ;


valor = {int} int_type | {real} real_type | {bool} bool_type | {var} identifier;


stmt = {op} opr
      | {exp_un} exp_un ;

opr = {mais}    soma stmt [stmt_l]:stmt
	 | {menos}   menos stmt [stmt_l]:stmt
	 | {vezes}   mult stmt [stmt_l]:stmt
	 | {frac}    div stmt [stmt_l]:stmt
	 | {igual}   igual_que stmt [stmt_l]:stmt
     | {meigual} menor_igual_que stmt [stmt_l]:stmt
     | {maigual} maior_igual_que stmt [stmt_l]:stmt
     | {menor}   menor_que stmt [stmt_l]:stmt
     | {maior}   maior_que stmt [stmt_l]:stmt
     | {and}     and_id stmt [stmt_l]:stmt
     | {or}      or_id stmt [stmt_l]:stmt 
     | {not}     not_id stmt ;

exp_un = {nomevar} var
      //| {parnts}  l_par stmt r_par
        | {chamada} chamada   
        | {constan} constante;

chamada = identifier l_par parametros? r_par ;

var = {vetor} identifier l_bracket stmt r_bracket
     | {id}    identifier ; 

comando = {if}       if_id l_par stmt r_par comando else_id [elsecomando]:comando
 		 | {while}    while l_par stmt r_par comando
 		 | {foreach}  foreach l_par tipo identifier double_dot [vectorid]:identifier r_par comando
 		 | {bloco}    bloco 
 		 | {sendback} exp_return
 		 | {patrib}   comando_atrib semicolon
       | {chamada}  chamada semicolon ;   

bloco = start_block_id decl_var* comando* end_block_id ;
 
bloco_funcao = start_block_id decl_var* comando* exp_return end_block_id ;
  
exp_return = return stmt? semicolon ;


constante = {intdec}  number
 	 	   | {intbin}    numero_bin
 		   | {inthex}    hex_number 
 		   | {char}      char_var
 		   | {string}    string 
 		   | {booltrue}  true_id
 		   | {boolfalse} false_id ;





Abstract Syntax Tree

 programa = decl_var* decl_func* ;
 
 
 decl_func = {tipo} tipo identifier decl_parametros? bloco_funcao 
           | {none} none identifier decl_parametros? bloco_funcao;

 
 decl_parametros = tipo identifier decl_param_adicional* ;
 decl_param_adicional = decl_parametro ;
 decl_parametro = tipo identifier ;

 parametros = stmt param_adicional* ;
 param_adicional = stmt ;

 decl_var = tipo identifier id_adicional*;

 id_adicional = identifier ;
 
 tipo = tipo_base stmt?;
 
 tipo_base = {int}  int
           | {char} char
           | {bool} bool;          