/* simpleAdder.sable - A very simple program that recognizes two integers being added. */
Package prefixa ;
    
Helpers
    /* Our helpers */	
    digito = ['0' .. '9'] ;
    hex_digit = digito | ['a'..'f'] | ['A'..'F'];
    espaco = ' ';
    rc = 13;
    nl = 10;
    all = [0 .. 0xffff];
    letter = [['a' .. 'z'] + ['A' .. 'Z']];
   	tab = 9;
    dot = '.';
    expo = 'E';
    name_part = letter (letter | digito | '_')*;
    name = name_part ('_' name_part)*;
    id = name;
    not_new_line = [all - nl];
    not_bracete_l = '{';
    not_new_aspa = [all - '"'];
    number = digito+;
    nondigit = ['_' + [['a' .. 'z'] + ['A' .. 'Z']]];
    hex_number = '0x' hex_digit+;
 
 States
  normal,
  comment;
 
Tokens
   vazio = (espaco | rc | nl | tab)+;
   atribuicao = '<<';
   char_id = 'char';
   int_id = 'integer';
   bool_id = 'bool';
   real_id = 'real';
   if_id = 'if';
   else_id = 'else';
   start_block_id = 'start';
   end_block_id =  'end';
   not_id = 'not';
   and_id = 'and';
   or_id = 'or';
   comma = ',';
   
   soma = '+';
   menos = '-';
   mult = '*';
   div = '/';
   mod = '%';
   par_esq = '(';
   par_dir = ')';
   double_dot = ':';
   bool_type = 'true' | 'false';
   while = 'while';
   do = 'do';
   for = 'for';
   each = 'each';
   l_par = '(';
   r_par = ')';
   l_bracket = '[';
   r_bracket = ']';
   l_brace = '{';
   r_brace = '}';
   igual_que = '=';
   menor_que = '<';
   menor_igual_que = '<=';
   maior_que = '>';
   maior_igual_que = '>=';
   semicolon = ';';
   return = 'send back';
   scan =  'scan';
   print = 'print';
   string = '"'(not_new_aspa)* '"';
   comments = '#'(not_new_line)* nl; 
   long_comment = '{' (not_bracete_l*) '}';
   int_type = number | hex_number;
   real_type = '-'? (number dot number | number (dot number)? expo '-'? number);
   identifier = nondigit (digito | nondigit)*;

Ignored Tokens
     vazio, comments, long_comment;
     

Productions

type =  {int} int_id | {bool} bool_id | {real} real_id | {char} char_id;

valor = {int} int_type | {real} real_type | {bool} bool_type | {var} identifier;

type_list = {unico} type | {varios} type comma [types]:type_list;


condicional = {if} if_id condicao bloco | {ifelse} condicional else_id bloco;

condicao = 
	 bool_type
	| {eq} valor igual
	| {mq} valor maior
	| {mn} valor menor
	| {mneq} valor menor_igual
	| {maeq} valor maior_igual
	| {neg} not_id condicao  
	| {and} condicao and
	| {or} condicao or
	| {cond} l_par condicao r_par;

igual = {eq} igual_que valor;

maior = {mq} maior_que valor;

menor = {mn} menor_que valor;

menor_igual = {mneq} menor_igual_que valor;

maior_igual = {maeq} maior_igual_que valor;

and = {and} and_id condicao;

or = {or} or_id condicao;


bloco = 
	{bloco} start_block_id function_declaration end_block_id ;


function_declaration = type function_declarator semicolon | {identifier} identifier function_declarator semicolon;


function_declarator =  {pointer} pointer_function | {direct} direct_function_declarator;

pointer_function =
{direct} atribuicao direct_function_declarator |
{pointer} atribuicao pointer_function;


direct_function_declarator =
	{identifier} identifier l_par parameter_list? r_par |
	{function} [plp]:l_par pointer_function [prp]:r_par [pllp]:l_par
	parameter_list? [plrp]:r_par;


parameter_list =
	parameter_declaration parameter_list_tail*;

parameter_list_tail =
	comma parameter_declaration;

parameter_declaration =
	type valor;


expr =
   {fator} fator 
  |{soma} soma expr fator 
  |{menos} menos expr fator;

fator =
   {termo} termo 
  |{mult} mult fator termo 
  |{div} div fator termo 
  |{mod} mod fator termo;
  
termo = {number} number | {par} par_esq expr par_dir;



statement =
   {comp_stmt} compound_statement |
   {basic_stmt} basic_statement semicolon |
   {if} if l_par condicional r_par compound_statement |
   {if_then_else} if l_par condicional r_par [then_comp_stmt]:compound_statement
   else [else_comp_stmt]:compound_statement |
   {if_else} if l_par condicional r_par semicolon else compound_statement |
   {while} while l_par condicional r_par compound_statement |
   {for} for l_par [start]:basic_statement? [sc_one]:semicolon condicional?
   [sc_two]:semicolon [iter]:basic_statement? r_par compound_statement

basic_statement =
   {call_expression} call_expression |
   {modify_expression} modify_expression |

compound_statement = l_brace statement* stop_statement? r_brace;

stop_statement =
   {return} return semicolon dead_code* |
   {return_value} return valor semicolon dead_code*
   {return_par} return l_par value r_par semicolon dead_code*;


dead_code =
{dead1} statement |
{dead3} return semicolon |
{dead4} return value semicolon |
{dead5} return l_par value r_par semicolon;

call_expression =
   identifier l_par parameter_list? r_par;     

modify_expression =
   {direct} identifier atribuicao;
